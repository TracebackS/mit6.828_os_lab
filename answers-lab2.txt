516030910459-邵欣阳

Part 1:

Exercise 1:

	boot_alloc(): 从内核代码的结尾（链接时产生的外部变量end）开始，向高地址分配包含n字节的整页空间。
	mem_init(): 使用boot_alloc()在extend memory上分配一块空间，存放物理页数组。
	page_init(): 初始化物理页状态，将未分配的物理页标记为free，存放在链表里。
	page_alloc(): 从空闲页链表中分配一个物理页，并在链表中删除该表项。
	page_free(): 检查该物理页是否真的空闲，并将其归还空闲页链表。

Part 2:

Exercise 2:

	Nothing to be done.

Exercise 3:

	Yes, indeed.

Exercise 4:

	pgdir_walk(): 如果页表缺失，则分配物理页作为页表。
	boot_map_region(): 将物理页地址循环填入页表。
	page_lookup(): 调用pgdir_walk()，查阅物理页的信息。
	page_remove(): 调用page_lookup()来检查并释放页。
	page_insert(): 将物理页绑定到制定虚拟页上，如果对应物理页已经绑定上去，则不作改动，否则ref加1。

Part 3:

Exercise 5:

	按照memlayout.h中的虚拟内存分布图，补全了mem_init()中的相关部分。

Question:

1.	x应该是uintptr_t类型，因为C中对指针进行了解引用操作，这个指针存放的一定是虚拟地址，x由该指针类型转化而来，也应该是虚拟地址。

2.	
	+-------+----------------------+---------------------------------------+
	| Entry | Base Virtual Address | Points to (logically):                |
	+-------+----------------------+---------------------------------------+
	| 1023  | 0xffc00000           | Page table for top 4MB of phys memory |
	+-------+----------------------+---------------------------------------+
	| 1022  | 0xff800000           | ?                                     |
	+-------+----------------------+---------------------------------------+
	| .     | ?                    | ?                                     |
	+-------+----------------------+---------------------------------------+
	| .     | ?                    | ?                                     |
	+-------+----------------------+---------------------------------------+
	| .     | ?                    | ?                                     |
	+-------+----------------------+---------------------------------------+
	| 2     | 0x00800000           | ?                                     |
	+-------+----------------------+---------------------------------------+
	| 1     | 0x00400000           | ?                                     |
	+-------+----------------------+---------------------------------------+
	| 0     | 0x00000000           | [see next question]                   |
	+-------+----------------------+---------------------------------------+

3.	page table entry会记录虚拟页的权限信息，可以因此保护内核的内存。

4.	256MB，因为kernel base以上只有256MB可索引的内存。

5.	4MB + 4KB。合理利用大页。

6.	kern/entry.S:69 jmp *%eax
	因为内核代码段和EIP所指的低地址段被映射到了同一段地址，所以可以继续使用原本的EIP执行内核代码。
	因为它开始初始化虚拟内存页的分布。

Challenge 1:

	启用内存大页：在boot_map_region()的基础上，直接在一级页表中插入大小为PTSIZE的大页，并在mem_init中操作cr4以启用大页。
